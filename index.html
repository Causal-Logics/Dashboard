<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategic Analysis & Casualty Prediction Suite</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet">

```
<style>
    body { font-family: 'JetBrains Mono', monospace; background-color: #020617; color: #f8fafc; margin: 0; }
    .tab-btn.active { border-bottom: 3px solid #10b981; color: #10b981; }
    .axiom-card { background: #0f172a; border: 1px solid #334155; transition: all 0.3s; }
    .axiom-card:hover { border-color: #10b981; transform: translateY(-2px); }
    .axiom-card.new-segment { 
        animation: slideIn 0.4s ease-out, highlight 2s ease-out;
        border-color: #3b82f6;
    }
    @keyframes slideIn {
        from { opacity: 0; transform: translateX(-20px); }
        to { opacity: 1; transform: translateX(0); }
    }
    @keyframes highlight {
        0% { background-color: #1e3a8a; }
        100% { background-color: #0f172a; }
    }
    .custom-scroll::-webkit-scrollbar { width: 6px; }
    .custom-scroll::-webkit-scrollbar-thumb { background: #334155; border-radius: 10px; }
</style>
```

</head>
<body>
    <div id="root"></div>

```
<script type="text/babel">
    const { useState, useEffect, useMemo, createElement: h } = React;

    // --- SHARED DATA ---
    const CAUSAL_AXIOMS = {
        Structural: { keywords: ["resource", "constraint", "budget", "funding", "material", "physical"] },
        Institutional: { keywords: ["law", "policy", "regulation", "mandate", "court", "authority"] },
        Ideational: { keywords: ["culture", "identity", "belief", "value", "tradition", "symbol"] },
        Psychological: { keywords: ["fear", "anger", "emotion", "bias", "instinct", "trauma"] }
    };

    const PROBABILITY_MAP = {
        'None': 0.05, 'Structural': 0.35, 'Ideational': 0.75, 'Institutional': 0.08,
        'Psychological': 0.12, 'Pos': 0.88, 'Structural+Ideational': 0.55
    };

    // --- COMPONENTS ---
    function App() {
        const [activeTab, setActiveTab] = useState('research');
        const [analysisHistory, setAnalysisHistory] = useState([]);
        const [selectedActorProfile, setSelectedActorProfile] = useState(null);

        // Function to "Bridge" the two codes
        const bridgeToSimulation = (actorName, scores, aggregatedData = null, casualtyData = null) => {
            setSelectedActorProfile({
                name: actorName,
                structural: scores.Structural > 0,
                institutional: scores.Institutional > 0,
                ideational: scores.Ideational > 0,
                psychological: scores.Psychological > 0,
                positional: Math.random() > 0.5, // Simulated detection
                aggregatedScores: aggregatedData ? aggregatedData : scores,
                isAggregated: aggregatedData !== null,
                casualtyData: casualtyData
            });
            setActiveTab('simulation');
        };

        // Function to aggregate all segments
        const sendAllToSimulator = (segments) => {
            if (segments.length === 0) return;

            // Aggregate all causal logic scores
            const aggregated = {
                Structural: 0,
                Institutional: 0,
                Ideational: 0,
                Psychological: 0
            };

            const actorSet = new Set();
            const sourceSet = new Set();
            let totalCasualties = 0;

            segments.forEach(segment => {
                Object.keys(aggregated).forEach(key => {
                    aggregated[key] += segment.scores[key] || 0;
                });
                actorSet.add(segment.actor);
                sourceSet.add(segment.source);
                totalCasualties += segment.casualties || 0;
            });

            const actorList = Array.from(actorSet).join(', ');
            const profileName = `Aggregated: ${actorList} (${segments.length} segments, ${sourceSet.size} sources)`;

            const casualtyData = {
                total: totalCasualties,
                average: (totalCasualties / segments.length).toFixed(1),
                segments: segments.length,
                perSource: segments.map(s => ({ source: s.source, casualties: s.casualties }))
            };

            bridgeToSimulation(profileName, aggregated, aggregated, casualtyData);
        };

        return (
            <div className="min-h-screen flex flex-col">
                {/* Header */}
                <header className="bg-slate-900 border-b border-slate-800 p-6 flex justify-between items-center">
                    <div>
                        <h1 className="text-xl font-bold text-emerald-400">STRATEGIC ANALYSIS SUITE v2.0</h1>
                        <p className="text-xs text-slate-400">NLP Extraction + Monte Carlo Simulation</p>
                    </div>
                    <nav className="flex gap-6">
                        <button onClick={() => setActiveTab('research')} className={`tab-btn pb-2 font-bold ${activeTab === 'research' ? 'active' : ''}`}>1. RESEARCH & NLP</button>
                        <button onClick={() => setActiveTab('simulation')} className={`tab-btn pb-2 font-bold ${activeTab === 'simulation' ? 'active' : ''}`}>2. CASUALTY SIMULATION</button>
                    </nav>
                </header>

                <main className="flex-1 p-6">
                    {activeTab === 'research' ?
                        <ResearchModule 
                            onActorExport={bridgeToSimulation} 
                            onSendAll={sendAllToSimulator}
                            history={analysisHistory} 
                            setHistory={setAnalysisHistory} 
                        /> :
                        <SimulationModule importedProfile={selectedActorProfile} />
                    }
                </main>
            </div>
        );
    }

    function ResearchModule({ onActorExport, onSendAll, history, setHistory }) {
        const [loading, setLoading] = useState(false);
        const [incident, setIncident] = useState("Sanctuary city policy");
        const [actors, setActors] = useState("ICE, Mayor");
        const [progress, setProgress] = useState("");

        // Clear "isNew" flag after animation completes
        useEffect(() => {
            const timer = setTimeout(() => {
                setHistory(prev => prev.map(item => ({ ...item, isNew: false })));
            }, 2000);
            return () => clearTimeout(timer);
        }, [history]);

        const generateMockSegments = (incidentText, actorList) => {
            const actorArray = actorList.split(',').map(a => a.trim());
            const templates = [
                {
                    text: "The institutional framework requires compliance with federal regulations and legal mandates...",
                    scores: { Structural: 1, Institutional: 4, Ideational: 0, Psychological: 1 },
                    casualties: Math.floor(Math.random() * 3) // Low casualties for institutional
                },
                {
                    text: "Resource constraints and budget limitations prevent full implementation of the policy...",
                    scores: { Structural: 4, Institutional: 1, Ideational: 0, Psychological: 0 },
                    casualties: Math.floor(Math.random() * 5)
                },
                {
                    text: "Community identity and cultural values drive strong resistance to the proposed changes...",
                    scores: { Structural: 0, Institutional: 0, Ideational: 4, Psychological: 2 },
                    casualties: Math.floor(Math.random() * 15) + 5 // Higher for ideational conflicts
                },
                {
                    text: "Fear and uncertainty among residents have escalated tensions in the community...",
                    scores: { Structural: 0, Institutional: 1, Ideational: 1, Psychological: 4 },
                    casualties: Math.floor(Math.random() * 12) + 3 // Moderate-high for psychological
                },
                {
                    text: "Court rulings and regulatory authority shape the boundaries of permissible action...",
                    scores: { Structural: 0, Institutional: 4, Ideational: 0, Psychological: 0 },
                    casualties: Math.floor(Math.random() * 2)
                },
                {
                    text: "Traditional beliefs and symbolic meanings inform the stakeholder response patterns...",
                    scores: { Structural: 0, Institutional: 1, Ideational: 4, Psychological: 1 },
                    casualties: Math.floor(Math.random() * 10) + 5
                },
                {
                    text: "Physical infrastructure and material resources determine operational capacity...",
                    scores: { Structural: 4, Institutional: 0, Ideational: 0, Psychological: 1 },
                    casualties: Math.floor(Math.random() * 8) + 2
                },
                {
                    text: "Emotional reactions and cognitive biases influence decision-making processes...",
                    scores: { Structural: 0, Institutional: 0, Ideational: 1, Psychological: 4 },
                    casualties: Math.floor(Math.random() * 10) + 2
                }
            ];

            const sources = [
                "New York Times", "Washington Post", "Local News Network", 
                "Associated Press", "Reuters", "City Tribune"
            ];

            const numSegments = Math.min(5 + Math.floor(Math.random() * 4), templates.length);
            const segments = [];
            const now = new Date();

            for (let i = 0; i < numSegments; i++) {
                const template = templates[i % templates.length];
                const actor = actorArray[Math.floor(Math.random() * actorArray.length)];
                const source = sources[Math.floor(Math.random() * sources.length)];
                
                // Generate sequential timestamps
                const segmentTime = new Date(now.getTime() + (i * 1000));
                const timeStr = segmentTime.toLocaleTimeString('en-US', { 
                    hour: '2-digit', 
                    minute: '2-digit', 
                    second: '2-digit' 
                });
                
                segments.push({
                    id: Date.now() + i,
                    timestamp: timeStr,
                    actor: actor,
                    source: source,
                    text: template.text,
                    scores: template.scores,
                    casualties: template.casualties,
                    isNew: true
                });
            }

            return segments;
        };

        const handleSearch = async () => {
            setLoading(true);
            setProgress("Initializing search pipeline...");
            
            await new Promise(resolve => setTimeout(resolve, 500));
            
            const segments = generateMockSegments(incident, actors);
            
            // Process each segment sequentially
            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                
                setProgress(`Processing ${segment.source} (${i + 1}/${segments.length})...`);
                await new Promise(resolve => setTimeout(resolve, 400));
                
                setProgress(`Extracting segment from ${segment.source}...`);
                await new Promise(resolve => setTimeout(resolve, 300));
                
                setProgress(`Running NLP classification on ${segment.source}...`);
                await new Promise(resolve => setTimeout(resolve, 400));
                
                // Add this segment to history
                setHistory(prev => [segment, ...prev]);
                
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            setProgress("Analysis complete!");
            await new Promise(resolve => setTimeout(resolve, 800));
            
            setProgress("");
            setLoading(false);
        };

        return (
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <section className="bg-slate-900 p-6 rounded-xl border border-slate-800">
                    <h2 className="text-emerald-400 font-bold mb-4 flex items-center gap-2"><span>üîç</span> INCIDENT PARAMETERS</h2>
                    <div className="space-y-4">
                        <div>
                            <label className="text-xs text-slate-500 block mb-1">INCIDENT DESCRIPTION</label>
                            <input value={incident} onChange={e => setIncident(e.target.value)} className="w-full bg-slate-800 border border-slate-700 p-3 rounded text-sm"/>
                        </div>
                        <div>
                            <label className="text-xs text-slate-500 block mb-1">KEY ACTORS (comma separated)</label>
                            <input value={actors} onChange={e => setActors(e.target.value)} className="w-full bg-slate-800 border border-slate-700 p-3 rounded text-sm"/>
                        </div>
                        <button onClick={handleSearch} disabled={loading} className="w-full bg-emerald-600 hover:bg-emerald-500 p-3 rounded font-bold transition-all disabled:opacity-50 disabled:cursor-not-allowed">
                            {loading ? "PROCESSING NLP..." : "START AUTOMATED RESEARCH"}
                        </button>
                        {progress && (
                            <div className="bg-blue-900/20 border border-blue-500/50 text-blue-400 text-xs p-3 rounded flex items-center gap-2">
                                <span className="animate-pulse">‚óè</span> {progress}
                            </div>
                        )}
                    </div>
                </section>

                <section className="bg-slate-900 p-6 rounded-xl border border-slate-800">
                    <div className="flex justify-between items-center mb-4">
                        <h2 className="text-emerald-400 font-bold">üìà LATEST ANALYZED SEGMENTS</h2>
                        <div className="flex gap-2 items-center">
                            {history.length > 0 && (
                                <>
                                    <span className="text-xs bg-emerald-900/30 text-emerald-400 px-2 py-1 rounded border border-emerald-500/50">
                                        {history.length} segments
                                    </span>
                                    <button 
                                        onClick={() => onSendAll(history)}
                                        className="text-[10px] bg-blue-900/30 text-blue-400 border border-blue-500/50 px-3 py-1 rounded hover:bg-blue-500 hover:text-white transition-all font-bold"
                                    >
                                        SEND ALL TO SIMULATOR ‚Üí
                                    </button>
                                    <button 
                                        onClick={() => setHistory([])}
                                        className="text-[10px] bg-red-900/30 text-red-400 border border-red-500/50 px-2 py-1 rounded hover:bg-red-500 hover:text-white transition-all"
                                    >
                                        CLEAR
                                    </button>
                                </>
                            )}
                        </div>
                    </div>
                    <div className="space-y-4 max-h-[500px] overflow-y-auto custom-scroll">
                        {history.length === 0 ? (
                            <p className="text-sm text-slate-500 italic text-center py-8">No segments analyzed yet. Start automated research to begin.</p>
                        ) : (
                            history.map(item => (
                                <div key={item.id} className={`axiom-card p-4 rounded-lg ${item.isNew ? 'new-segment' : ''}`}>
                                    <div className="flex justify-between mb-2">
                                        <div>
                                            <span className="text-xs font-bold text-blue-400 uppercase">{item.actor}</span>
                                            {item.source && <span className="text-[10px] text-slate-500 ml-2">via {item.source}</span>}
                                        </div>
                                        <div className="flex items-center gap-2">
                                            {item.casualties !== undefined && (
                                                <span className="text-[10px] bg-red-900/30 text-red-400 border border-red-500/50 px-2 py-1 rounded font-bold">
                                                    {item.casualties} casualties
                                                </span>
                                            )}
                                            <span className="text-[10px] text-slate-500">{item.timestamp}</span>
                                        </div>
                                    </div>
                                    <p className="text-xs italic text-slate-300 mb-3">"{item.text}"</p>
                                    <div className="flex justify-between items-center">
                                        <div className="flex gap-2 flex-wrap">
                                            {Object.entries(item.scores).map(([k, v]) => v > 0 && (
                                                <span key={k} className="text-[10px] bg-slate-800 px-2 py-1 rounded border border-slate-700">
                                                    {k}: {v}
                                                </span>
                                            ))}
                                        </div>
                                        <button onClick={() => onActorExport(item.actor, item.scores)} className="text-[10px] bg-emerald-900/50 text-emerald-400 border border-emerald-500/50 px-2 py-1 rounded hover:bg-emerald-500 hover:text-white transition-all whitespace-nowrap ml-2">
                                            SEND TO SIMULATOR ‚Üí
                                        </button>
                                    </div>
                                </div>
                            ))
                        )}
                    </div>
                </section>
            </div>
        );
    }

    function SimulationModule({ importedProfile }) {
        const [actorA, setActorA] = useState({
            name: 'Actor A',
            behaviors: { structural: true, ideational: false, institutional: false, psychological: false, positional: false }
        });
        const [actorB, setActorB] = useState({
            name: 'Actor B',
            behaviors: { structural: false, ideational: true, institutional: false, psychological: false, positional: false }
        });
        const [simResults, setSimResults] = useState(null);
        const [activeActor, setActiveActor] = useState('both'); // 'A', 'B', or 'both'
        const [casualtyData, setCasualtyData] = useState(null);

        useEffect(() => {
            if (importedProfile) {
                // Set casualty data if available
                if (importedProfile.casualtyData) {
                    setCasualtyData(importedProfile.casualtyData);
                }

                // Check if this is an aggregated profile with multiple actors
                if (importedProfile.isAggregated && importedProfile.name.includes(',')) {
                    // Try to split actors
                    const actorNames = importedProfile.name.split(':')[1]?.split('(')[0]?.split(',').map(a => a.trim()) || [];
                    if (actorNames.length >= 2) {
                        setActorA(prev => ({
                            ...prev,
                            name: actorNames[0],
                            behaviors: {
                                structural: importedProfile.structural,
                                ideational: importedProfile.ideational,
                                institutional: importedProfile.institutional,
                                psychological: importedProfile.psychological,
                                positional: importedProfile.positional
                            }
                        }));
                        setActorB(prev => ({
                            ...prev,
                            name: actorNames[1],
                            behaviors: {
                                structural: importedProfile.structural,
                                ideational: importedProfile.ideational,
                                institutional: importedProfile.institutional,
                                psychological: importedProfile.psychological,
                                positional: importedProfile.positional
                            }
                        }));
                    }
                } else {
                    // Single actor import
                    setActorA(prev => ({
                        ...prev,
                        name: importedProfile.name,
                        behaviors: {
                            structural: importedProfile.structural,
                            ideational: importedProfile.ideational,
                            institutional: importedProfile.institutional,
                            psychological: importedProfile.psychological,
                            positional: importedProfile.positional
                        }
                    }));
                }
            }
        }, [importedProfile]);

        useEffect(() => {
            runSimulation();
        }, [actorA.behaviors, actorB.behaviors, activeActor, casualtyData]);

        const runSimulation = () => {
            const iterations = 1000;
            const resultsA = [];
            const resultsB = [];
            const resultsCombined = [];
            
            // Use casualty data to calibrate baseline if available
            let baselineCasualties = 0;
            if (casualtyData) {
                baselineCasualties = parseFloat(casualtyData.average);
            }
            
            for (let i = 0; i < iterations; i++) {
                // Actor A simulation
                let probA = PROBABILITY_MAP['None'];
                if (actorA.behaviors.structural) probA = Math.max(probA, PROBABILITY_MAP['Structural']);
                if (actorA.behaviors.ideational) probA = Math.max(probA, PROBABILITY_MAP['Ideational']);
                if (actorA.behaviors.institutional) probA = Math.max(probA, PROBABILITY_MAP['Institutional']);
                if (actorA.behaviors.psychological) probA = Math.max(probA, PROBABILITY_MAP['Psychological']);
                if (actorA.behaviors.positional) probA = Math.max(probA, PROBABILITY_MAP['Pos']);
                const varianceA = (Math.random() - 0.5) * 0.1;
                resultsA.push(Math.max(0, Math.min(1, probA + varianceA)));

                // Actor B simulation
                let probB = PROBABILITY_MAP['None'];
                if (actorB.behaviors.structural) probB = Math.max(probB, PROBABILITY_MAP['Structural']);
                if (actorB.behaviors.ideational) probB = Math.max(probB, PROBABILITY_MAP['Ideational']);
                if (actorB.behaviors.institutional) probB = Math.max(probB, PROBABILITY_MAP['Institutional']);
                if (actorB.behaviors.psychological) probB = Math.max(probB, PROBABILITY_MAP['Psychological']);
                if (actorB.behaviors.positional) probB = Math.max(probB, PROBABILITY_MAP['Pos']);
                const varianceB = (Math.random() - 0.5) * 0.1;
                resultsB.push(Math.max(0, Math.min(1, probB + varianceB)));

                // Combined interaction (max of both)
                resultsCombined.push(Math.max(resultsA[i], resultsB[i]));
            }
            
            // Convert probabilities to casualty estimates (scale by baseline if available)
            const maxCasualties = baselineCasualties > 0 ? baselineCasualties * 2 : 50;
            const casualtiesA = resultsA.map(p => p * maxCasualties);
            const casualtiesB = resultsB.map(p => p * maxCasualties);
            const casualtiesCombined = resultsCombined.map(p => p * maxCasualties);
            
            setSimResults({ 
                actorA: resultsA, 
                actorB: resultsB, 
                combined: resultsCombined,
                casualtiesA: casualtiesA,
                casualtiesB: casualtiesB,
                casualtiesCombined: casualtiesCombined,
                maxCasualties: maxCasualties
            });
            plotDistribution(casualtiesA, casualtiesB, casualtiesCombined, maxCasualties);
        };

        const plotDistribution = (casualtiesA, casualtiesB, casualtiesCombined, maxCasualties) => {
            const traces = [];

            if (activeActor === 'A' || activeActor === 'both') {
                traces.push({
                    x: casualtiesA,
                    type: 'histogram',
                    nbinsx: 30,
                    name: actorA.name,
                    marker: { color: '#3b82f6', opacity: 0.6 },
                    visible: activeActor === 'both' ? true : true
                });
            }

            if (activeActor === 'B' || activeActor === 'both') {
                traces.push({
                    x: casualtiesB,
                    type: 'histogram',
                    nbinsx: 30,
                    name: actorB.name,
                    marker: { color: '#ef4444', opacity: 0.6 },
                    visible: activeActor === 'both' ? true : true
                });
            }

            if (activeActor === 'both') {
                traces.push({
                    x: casualtiesCombined,
                    type: 'histogram',
                    nbinsx: 30,
                    name: 'Combined (Max)',
                    marker: { color: '#10b981', opacity: 0.7 },
                    visible: true
                });
            }

            // Add observed casualty line if available
            if (casualtyData && casualtyData.average) {
                const avgCasualty = parseFloat(casualtyData.average);
                traces.push({
                    x: [avgCasualty, avgCasualty],
                    y: [0, 100],
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Observed Avg',
                    line: { color: '#fbbf24', width: 3, dash: 'dash' }
                });
            }

            const layout = {
                title: { text: 'Predicted Casualty Distribution', font: { color: '#f8fafc' } },
                xaxis: { 
                    title: 'Estimated Casualties', 
                    color: '#94a3b8', 
                    range: [0, maxCasualties]
                },
                yaxis: { title: 'Frequency', color: '#94a3b8' },
                plot_bgcolor: '#0f172a',
                paper_bgcolor: '#0f172a',
                font: { color: '#f8fafc' },
                barmode: 'overlay',
                showlegend: true,
                legend: { x: 0.65, y: 0.95, bgcolor: '#1e293b', bordercolor: '#334155', borderwidth: 1 }
            };

            Plotly.newPlot('chart', traces, layout, { responsive: true });
        };

        const avgCasA = simResults ? (simResults.casualtiesA.reduce((a, b) => a + b, 0) / simResults.casualtiesA.length).toFixed(1) : '---';
        const avgCasB = simResults ? (simResults.casualtiesB.reduce((a, b) => a + b, 0) / simResults.casualtiesB.length).toFixed(1) : '---';
        const avgCasCombined = simResults ? (simResults.casualtiesCombined.reduce((a, b) => a + b, 0) / simResults.casualtiesCombined.length).toFixed(1) : '---';

        return (
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                <div className="lg:col-span-1 space-y-6">
                    {/* Observed Casualties Panel */}
                    {casualtyData && (
                        <div className="bg-slate-900 p-6 rounded-xl border border-yellow-500/50">
                            <h2 className="text-yellow-400 font-bold mb-3">üìä OBSERVED DATA</h2>
                            <div className="space-y-2">
                                <div className="flex justify-between text-xs">
                                    <span className="text-slate-400">Total Casualties:</span>
                                    <span className="text-white font-bold">{casualtyData.total}</span>
                                </div>
                                <div className="flex justify-between text-xs">
                                    <span className="text-slate-400">Average per Segment:</span>
                                    <span className="text-yellow-400 font-bold">{casualtyData.average}</span>
                                </div>
                                <div className="flex justify-between text-xs">
                                    <span className="text-slate-400">Segments Analyzed:</span>
                                    <span className="text-white font-bold">{casualtyData.segments}</span>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Actor A Profile */}
                    <div className="bg-slate-900 p-6 rounded-xl border border-blue-500/50">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-blue-400 font-bold">ACTOR A</h2>
                            <input 
                                value={actorA.name} 
                                onChange={(e) => setActorA({...actorA, name: e.target.value})}
                                className="text-xs bg-slate-800 border border-slate-700 px-2 py-1 rounded w-24"
                            />
                        </div>
                        <div className="space-y-2">
                            {Object.keys(actorA.behaviors).map(key => (
                                <button
                                    key={key}
                                    onClick={() => setActorA({
                                        ...actorA, 
                                        behaviors: {...actorA.behaviors, [key]: !actorA.behaviors[key]}
                                    })}
                                    className={`w-full text-left p-2 rounded border text-xs font-bold transition-all ${actorA.behaviors[key] ? 'bg-blue-600 border-blue-400 text-white' : 'bg-slate-800 border-slate-700 text-slate-400'}`}
                                >
                                    {key.toUpperCase()} {actorA.behaviors[key] ? '‚úì' : '‚úó'}
                                </button>
                            ))}
                        </div>
                    </div>

                    {/* Actor B Profile */}
                    <div className="bg-slate-900 p-6 rounded-xl border border-red-500/50">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-red-400 font-bold">ACTOR B</h2>
                            <input 
                                value={actorB.name} 
                                onChange={(e) => setActorB({...actorB, name: e.target.value})}
                                className="text-xs bg-slate-800 border border-slate-700 px-2 py-1 rounded w-24"
                            />
                        </div>
                        <div className="space-y-2">
                            {Object.keys(actorB.behaviors).map(key => (
                                <button
                                    key={key}
                                    onClick={() => setActorB({
                                        ...actorB, 
                                        behaviors: {...actorB.behaviors, [key]: !actorB.behaviors[key]}
                                    })}
                                    className={`w-full text-left p-2 rounded border text-xs font-bold transition-all ${actorB.behaviors[key] ? 'bg-red-600 border-red-400 text-white' : 'bg-slate-800 border-slate-700 text-slate-400'}`}
                                >
                                    {key.toUpperCase()} {actorB.behaviors[key] ? '‚úì' : '‚úó'}
                                </button>
                            ))}
                        </div>
                    </div>

                    {/* Results */}
                    <div className="bg-slate-900 p-6 rounded-xl border border-slate-800">
                        <h2 className="text-emerald-400 font-bold mb-4">PREDICTED CASUALTIES</h2>
                        <div className="space-y-3">
                            <div className="text-center p-2 bg-blue-900/20 rounded border border-blue-500/30">
                                <div className="text-2xl font-bold text-blue-400">{avgCasA}</div>
                                <div className="text-[10px] text-slate-400">Actor A Avg</div>
                            </div>
                            <div className="text-center p-2 bg-red-900/20 rounded border border-red-500/30">
                                <div className="text-2xl font-bold text-red-400">{avgCasB}</div>
                                <div className="text-[10px] text-slate-400">Actor B Avg</div>
                            </div>
                            <div className="text-center p-2 bg-emerald-900/20 rounded border border-emerald-500/30">
                                <div className="text-2xl font-bold text-emerald-400">{avgCasCombined}</div>
                                <div className="text-[10px] text-slate-400">Combined Max</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div className="lg:col-span-2 bg-slate-900 p-6 rounded-xl border border-slate-800 min-h-[400px]">
                    <div className="flex justify-between items-center mb-4">
                        <h2 className="text-emerald-400 font-bold">CASUALTY PREDICTION</h2>
                        <div className="flex gap-2">
                            <button 
                                onClick={() => setActiveActor('A')}
                                className={`text-xs px-3 py-1 rounded border transition-all ${activeActor === 'A' ? 'bg-blue-600 border-blue-400 text-white' : 'bg-slate-800 border-slate-700 text-slate-400'}`}
                            >
                                A Only
                            </button>
                            <button 
                                onClick={() => setActiveActor('B')}
                                className={`text-xs px-3 py-1 rounded border transition-all ${activeActor === 'B' ? 'bg-red-600 border-red-400 text-white' : 'bg-slate-800 border-slate-700 text-slate-400'}`}
                            >
                                B Only
                            </button>
                            <button 
                                onClick={() => setActiveActor('both')}
                                className={`text-xs px-3 py-1 rounded border transition-all ${activeActor === 'both' ? 'bg-emerald-600 border-emerald-400 text-white' : 'bg-slate-800 border-slate-700 text-slate-400'}`}
                            >
                                Both
                            </button>
                        </div>
                    </div>
                    <div id="chart" className="w-full h-[400px]"></div>
                    <p className="text-[10px] text-slate-500 mt-4 italic text-center">
                        Monte Carlo simulation with 1000 iterations. Yellow dashed line shows observed average casualties from NLP analysis.
                    </p>
                </div>
            </div>
        );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(h(App));
</script>
```

</body>
</html>
